# Immutable типове - типове, които не могат да се променят - int, float, boolean, string, tuple
a = 1
b = a
print(a, b) # 1 1
a += 1
print(a, b) # 2 1

# В този пример реално числото 1 не се е увеличило, а се е създала нова клетка памет със стойност 2
# която се запазва в променливата 'a', докато 1-цата остава в 'b'

# Mutable типове - типове, които могат да се променят - list, dict, set и почти всичко останало :D
a = [1, 2, 3, 4]
b = a
print(a, b) # [1, 2, 3, 4] [1, 2, 3, 4]
a.append(5)
print(a, b) # [1, 2, 3, 4, 5] [1, 2, 3, 4, 5]

# Понеже list e mutable, то клетката памет в която се пази [1, 2, 3, 4] се променя. Тогава
# и двете променливи 'a' и 'b' остават да "сочат" към тази памет и съответно и двете
# стават със стойност [1, 2, 3, 4, 5]


# Функции
# Функция представлява блок от код, който се изпълнява само когато бъде извикан
# Всяка функция може да връща стойност и/или да приема някакви аргументи
# Реално ние вече сме се сблъсквали с много "вградени" в python функции - print(), max(), range() и др.

# Използваме ключовата дума 'def', за да дефинираме функция, последвана от името,
# което желаем нашата фунцкия да притежава и накрая две кръгли скоби
def myFunc():
    print("This code is from myFunc()")
    print("This is also from myFunc()")

# Извикваме функция като използваме името и, последвано от кръгли скоби
myFunc()

# Може да викаме фунцкиите колкото пъти си искаме
myFunc()
myFunc()
myFunc()

# Може да подаваме данни на функция във вида на аргументи
# Те се обозначават в кръглите скоби след името на функцията
# Може да добавяме колкото аргумента си искаме, като ги разделяме със запетая

def oneArgFunc(name):
  print("Hello, " + name)

def twoArgFunc(name, lastName):
   print(name + " " + lastName)

oneArgFunc("Ivan") # "Hello, Ivan"
oneArgFunc("Gosho") # "Hello, Gosho"

twoArgFunc("Pesho", "Peshev") # "Pesho Peshev"
# twoArgFunc("Jivko") -- това ще гръмне, понеже очаква точно 2 аргумента, а му е подаден само 1

# За да може да подаваме произволен брой аргументи на функция, то
# трябва към нейн аргумент да добавим *
# По този начин този аргумент ще съдържа tuple от всички подадени стойности

def manyArgs(*args):
   print(args)

manyArgs() # ()
manyArgs(1, 2) # (1, 2)
manyArgs(1, 2, 3, 4, 5) # (1, 2, 3, 4, 5)

# С ключови думи (keywords) и синтаксиса key = value, може
# да подаваме аргументи в разбъркан ред, като с key отбелязваме тяхното име
# в дефиницията на функцията

def keyWordFunc(a, b, c):
   print(a, b, c)

keyWordFunc(b = 2, c = 5, a = 1) # 1 2 5
keyWordFunc(a = 2, b = 5, c = 1) # 2 5 1

# Ако искаме да подадем произволен брой keyword аргументи, то
# трябва да добавим ** към аргумент на фунцкяита
# Тогава всички keyword аргументи ще влязат в него под формата на dict

def kwargsFunc(**kwargs):
   print(kwargs)

kwargsFunc() # {}
kwargsFunc(a = 5, b = 3) # {a: 5, b: 3}
kwargsFunc(a = 10, b = 20, ivan = "asd") # {a: 10, b: 20, ivan: "asd"}

# В скобите на дефиницията на фунцкия може да слагаме стойности по подразбиране
# на аргументите. По този начин ако фунцкия бъде извикана без тези аргументи, те ще се 
# "запълянт" със тези стойности по подразбиране

def defaultFunc(name = "DefaultName"):
   print("Hello, " + name)

defaultFunc("Ivan") # "Hello, Ivan"
defaultFunc() # "Hello, DefaultName"

# Използваме ключовата дума 'return', за да върнем стойност с нашата фунцкяи
# Важно! - всички редове код от функцията след извикване на return няма да бъдат изпълнени

def getSum(a, b):
   return a + b

def codeAfterReturn():
    return "The end"
    print("???")

c = getSum(5, 10) # c = 15

codeAfterReturn() # връща "The end", "???" не се принтира никога